ForaModel = require('./foramodel').ForaModel
ForaDbModel = require('./foramodel').ForaDbModel
utils = require('../lib/utils')
Q = require('../lib/q')
models = require('./')

class Collection extends ForaDbModel

    class Settings extends ForaModel

        @typeDefinition: {
            type: @,
            alias: "Collection.Settings",
            fields: {
                commentsEnabled: 'boolean !required',
                commentsOpened: 'boolean !required',
            }
        }

    @Settings: Settings

    class Summary extends ForaModel   
        @typeDefinition: {
            type: @,
            alias: "Collection.Summary",
            fields: {
                id: 'string',
                network: 'string',
                name: 'string',
                stub: 'string',
                createdBy: "User.Summary" 
            }
        }    

    @Summary: Summary

    class Stats extends ForaModel   
        @typeDefinition: {
            type: @,
            alias: "Collection.Stats",
            fields: {
                records: 'number',
                members: 'number',
                lastRecord: 'number'
            }
        }
        
    @Stats: Stats

    @childModels: { Stats, Summary, Settings }

    @typeDefinition: -> {
        type: @,
        alias: 'Collection',
        collection: 'collections',
        fields: {
            network: 'string',
            name: 'string',
            stub: 'string',
            type: { type: 'string', $in: ['public', 'protected', 'private'] },
            recordTypes: { type: 'array', contents: 'string', map: { format: 'csv' } },
            settings: "Collection.Settings !required",
            icon: 'string',
            iconThumbnail: 'string',
            cover: 'string !required',
            createdBy: "User.Summary",
            snapshot: '',            
            stats: "Collection.Stats",
            createdAt: { autoGenerated: true, event: 'created' },
            updatedAt: { autoGenerated: true, event: 'updated' }
        },
        associations: {
            info: { type: "CollectionInfo", key: { '_id': 'collectionid' } }
        },
        logging: {
                onInsert: 'NEW_FORUM'
        }
    }
        
    
    save: (context, db) =>        
        if not @_id
            @stats = new Stats {
                records: 0,
                members: 1,
                lastRecord: 0
            }
            @recordTypes ?= ['Article']
            @snapshot ?= { records: [] }
        
        super


        
    summarize: =>        
        summary = new Summary {
            id: @_id.toString()
            network: @network,
            name: @name,
            stub: @stub,
            createdBy: @createdBy
        }
        
        
        
    getView: (name = "standard") =>
        switch name
            when 'card'
                {
                    id: @_id.toString()
                    @network,
                    @name,
                    @stub,
                    @createdBy,
                    @snapshot,
                    image: @icon
                }



    join: (user, token, context, db) => 
        { context, db } = @getContext context, db
        (Q.async =>
            if @type is 'public'
                yield @addRole user, 'member', context, db
            else
                throw new Error "Access denied"
        )()
        
        
        
    addRecord: (record, context, db) =>
        { context, db } = @getContext context, db
        (Q.async =>
            record.collection = @summarize()
            yield record.save context, db
        )()
        


    getRecords: (limit, sort, context, db) =>
        { context, db } = @getContext context, db
        (Q.async =>
            yield models.Record.find({ 'collection.stub': @stub, 'collection.network': @network }, ((cursor) -> cursor.sort(sort).limit limit), context, db)
        )()
        

    
    addRole: (user, role, context, db) =>
        { context, db } = @getContext context, db
        
        (Q.async =>
            membership = yield models.Membership.get { 'collection.id': @_id.toString(), 'user.username': user.username }, context, db
            if not membership
                membership = new (models.Membership) {
                    collection: @summarize(),
                    user: user,
                    roles: [role]
                }
            else
                if membership.roles.indexOf(role) is -1 
                    membership.roles.push role
            yield membership.save context, db   
        )()
                


    removeRole: (user, role, context, db) =>
        { context, db } = @getContext context, db
        
        (Q.async =>
            membership = yield models.Membership.get { 'collection.id': @_id.toString(), 'user.username': user.username }, context, db
            membership.roles = (r for r in membership.roles when r isnt role)
            yield if membership.roles.length then membership.save() else membership.destroy()
        )()
                
    
                                
    getMemberships: (roles, context, db) =>
        { context, db } = @getContext context, db
        (Q.async =>
            yield models.Membership.find { 'collection.id': @_id.toString(), roles: { $in: roles } }, ((cursor) -> cursor.sort({ id: -1 }).limit 200), context, db
        )()        
        
      
            
    refreshSnapshot: (context, db) =>
        { context, db } = @getContext context, db
        (Q.async =>
            records = yield models.Record.find({ 'collection.id': @_id.toString() , state: 'published' }, ((cursor) -> cursor.sort({ _id: -1 }).limit 10), context, db)            
            @snapshot = { records: (p.getView("snapshot") for p in records) }
            if records.length
                cursor = yield models.Record.getCursor({ 'collection.id': @_id.toString() , state: 'published' }, context, db)
                @stats.records = yield Q.ninvoke cursor, 'count'
                @stats.lastRecord = records[0].savedAt
                yield @save context, db
        )()


exports.Collection = Collection

