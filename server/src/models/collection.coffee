ForaModel = require('./foramodel').ForaModel
ForaDbModel = require('./foramodel').ForaDbModel
utils = require('../lib/utils')
Q = require('../lib/q')
models = require('./')

class Collection extends ForaDbModel

    class Settings extends ForaModel
        @describeType: {
            type: @,
            fields: {
                comments: {
                    type: 'object',
                    required: false,
                    fields: {
                        enabled: { type: 'boolean', required: false },
                        opened: { type: 'boolean', required: false }
                    }
                }
            }
        }    
            
    @Settings: Settings            
        
    class Summary extends ForaModel   
        @describeType: {
            type: @,
            fields: {
                id: 'string',
                network: 'string',
                name: 'string',
                stub: 'string',
                createdBy: models.User.Summary
            }
        }    
            
    @Summary: Summary


    @describeType: -> {
        type: @,
        collection: 'collections',
        fields: {
            network: 'string',
            name: 'string',
            stub: 'string',
            type: { type: 'string', $in: ['public', 'protected', 'private'] },
            recordTypes: { type: 'array', contentType: 'string', map: { sourceFormat: 'csv' } },
            settings: { type: Settings },
            icon: 'string',
            iconThumbnail: 'string',
            cover: { type: 'string', required: false },
            createdBy: { type: models.User.Summary },
            snapshot: 'object',            
            stats: {
                type: 'object',
                fields: {
                    records: 'number',
                    members: 'number',
                    lastRecord: 'number'
                }
            },
            createdAt: { autoGenerated: true, event: 'created' },
            updatedAt: { autoGenerated: true, event: 'updated' }
        },
        associations: {
            info: { type: models.CollectionInfo, key: { '_id': 'collectionid' } }
        },
        logging: {
                onInsert: 'NEW_FORUM'
        }
    }
        
        
    save: (context, db) =>        
        if not @_id
            @stats ?= {
                records: 0,
                members: 1,
                lastRecord: 0
            }
            @snapshot ?= { records: [] }
        
        super


        
    summarize: =>        
        summary = new Summary {
            id: @_id.toString()
            network: @network,
            name: @name,
            stub: @stub,
            createdBy: @createdBy
        }
        
        
        
    getView: (name = "standard") =>
        switch name
            when 'card'
                {
                    id: @_id.toString()
                    @network,
                    @name,
                    @stub,
                    @createdBy,
                    @snapshot,
                    image: @icon
                }



    join: (user, token, context, db) => 
        { context, db } = @getContext context, db
        (Q.async =>
            if @type is 'public'
                yield @addRole user, 'member', context, db
            else
                throw new Error "Access denied"
        )()
        
        
        
    addRecord: (record, context, db) =>
        { context, db } = @getContext context, db
        (Q.async =>
            record.collection = @summarize()
            yield record.save context, db
        )()
        


    getRecords: (limit, sort, context, db) =>
        { context, db } = @getContext context, db
        (Q.async =>
            yield models.Record.find({ 'collection.stub': @stub, 'collection.network': @network }, ((cursor) -> cursor.sort(sort).limit limit), context, db)
        )()
        

    
    addRole: (user, role, context, db) =>
        { context, db } = @getContext context, db
        
        (Q.async =>
            membership = yield models.Membership.get { 'collection.id': @_id.toString(), 'user.id': user.id }, context, db
            if not membership
                membership = new (models.Membership) {
                    collection: @summarize(),
                    user: user,
                    roles: [role]
                }
            else
                if membership.roles.indexOf(role) is -1 
                    membership.roles.push role
            yield membership.save context, db   
        )()
                


    removeRole: (user, role, context, db) =>
        { context, db } = @getContext context, db
        
        (Q.async =>
            membership = yield models.Membership.get { 'collection.id': @_id.toString(), 'user.id': user.id }, context, db
            membership.roles = (r for r in membership.roles when r isnt role)
            yield if membership.roles.length then membership.save() else membership.destroy()
        )()
                
    
                                
    getMemberships: (roles, context, db) =>
        { context, db } = @getContext context, db
        (Q.async =>
            yield models.Membership.find { 'collection.id': @_id.toString(), roles: { $in: roles } }, ((cursor) -> cursor.sort({ id: -1 }).limit 200), context, db
        )()        
        
                
            
    refreshSnapshot: (context, db) =>
        { context, db } = @getContext context, db
        (Q.async =>
            records = yield models.Record.find({ 'collection.id': @_id.toString() , state: 'published' }, ((cursor) -> cursor.sort({ _id: -1 }).limit 10), context, db)
            @snapshot = { records: p.getView("snapshot") for p in records }
            if records.length
                @stats.lastRecord = records[0].savedAt
            yield @save context, db)()


exports.Collection = Collection
