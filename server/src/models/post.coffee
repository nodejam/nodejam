async = require '../common/async'
utils = require '../common/utils'
AppError = require('../common/apperror').AppError
mdparser = require('../common/markdownutil').marked
BaseModel = require('./basemodel').BaseModel
Q = require('../common/q')

class Post extends BaseModel
    
    @describeModel: ->
        models = @getModels()
        forumModule = require('./forum')
        {
            type: Post,
            collection: 'posts',
            discriminator: (obj) -> if obj.type is 'article' then models.Article,
            fields: {
                type: 'string',
                forum: { type: models.Forum.Summary },
                createdBy: { type: models.User.Summary, validate: -> @createdBy.validate() },
                meta: { type: 'array', contents: 'string' },
                stub: { type: 'string' },
                state: { type: 'string', validate: -> ['draft','published'].indexOf(@state) isnt -1 },
                title: 'string',
                recommendations: { type: 'array', contents: models.User.Summary, validate: -> user.validate() for user in @recommendations },                                
                publishedAt: { type: 'number', required: false, validate: -> not (@state is 'published' and not @publishedAt) },
                createdAt: { autoGenerated: true, event: 'created' },
                updatedAt: { autoGenerated: true, event: 'updated' }
            },
            concurrency: 'optimistic',
            logging: {
                isLogged: true,
                onInsert: 'NEW_POST'
            }
        }



    @search: (criteria, settings, context, db) =>
        limit = @getLimit settings.limit, 100, 1000
                
        params = {}
        for k, v of criteria
            params[k] = v
        
        Post.find params, ((cursor) -> cursor.sort(settings.sort).limit limit), context, db
        
        
    
    constructor: (params) ->
        super
        @recommendations ?= []
        @meta ?= []
        @tags ?= []
        @rating ?= 1
        @createdAt ?= Date.now()
        
        
    
    save: (context, db) =>        
        (Q.async =>        
            #Make sure we aren't overwriting another post with the same stub in the same forum.
            post = yield Post.get({ @stub, 'forum.id': @forum.id }, context, db)    
            if post and (post._id.toString() isnt @_id?.toString()) #Same post?
                if @_id
                    #We prefix the id so that sameness goes away                    
                    @stub = @_id?.toString() + "-" + @stub
                else
                    #No id yet. So, we'll do this once the post gets saved and gets an id.
                    stub = @stub
                    @stub = undefined
            post = yield super(context, db)
            if stub
                post.stub = post._id.toString() + "-" + stub
                post = yield post.save(context, db)

            if @state is 'published'
                @getModels().Forum.getById(@forum.id, context, db)
                    .then (forum) =>
                        forum.refreshSnapshot(context, db)
            
            return post)()

        
            
exports.Post = Post
