(function() {

    "use strict";

    var generatorify = require('nodefunc-generatorify'),
        hasher = require('fora-lib-hasher'),
        randomizer = require('fora-lib-randomizer'),
        models = require('./'),
        services = require('fora-lib-services'),
        DbConnector = require('fora-lib-db-connector'),
        dataUtils = require('fora-lib-data-utils'),
        Parser = require('ceramic-dictionary-parser');

    var schemaManager = services.getSchemaManager(),
        conf = services.getConfiguration();

    var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

    var Credential = function(params) {
        dataUtils.extend(this, params);
    };

    var credentialStore = new DbConnector(Credential);

    Credential.entitySchema = {
        collection: 'credentials',
        schema: {
            id: 'credential',
            type: 'object',
            properties: {
                email: { type: 'string' },
                emailIsVerified: { type: 'boolean' },
                preferences: {
                    type: 'object',
                    schema: {
                        properties: {
                            canEmail: { type: 'boolean' }
                        }
                    }
                },
                builtin: {
                    type: 'object',
                    schema: {
                        properties: {
                            hash: { type: 'string' },
                            salt: { type: 'string' }
                        },
                        required: [ 'hash', 'salt' ]
                    }
                },
                twitter: {
                    type: 'object',
                    schema: {
                        properties: {
                            id: { type: 'string' },
                            username: { type: 'string' },
                            accessToken: { type: 'string' },
                            accessTokenSecret: { type: 'string' }
                        },
                        required: [ 'id', 'username', 'accessToken', 'accessTokenSecret' ]
                    }
                },
                facebook: {
                    type: 'object',
                    schema: {
                        properties: {
                            id: { type: 'string' },
                            username: { type: 'string' },
                            accessToken: { type: 'string' }
                        },
                        required: [ 'id', 'username', 'accessToken' ]
                    }
                }
            }
        },
        autoGenerated: {
            createdAt: { event: 'created' },
            updatedAt: { event: 'updated' }
        },
        indexes: [
            { 'type': 1, 'email': 1 },
        ],
        links: {
            users: { type: 'user', field: 'credentialId' }
        },
        validate: function*(fields) {
            if (this.email && !emailRegex.test(this.email))
                return ['Invalid email'];
        }
    };


    Credential.createViaRequest = function*(request) {
        var schemaManager = services.getSchemaManager();
        var parser = new Parser(request, request.getFormField, schemaManager);

        if ((yield* parser.getField('secret')) === conf.services.auth.adminkeys.default) {
            var type = yield* parser.getField('type');

            var credential = new Credential(
                {
                    email: yield* parser.getField('email'),
                    preferences: { canEmail: true }
                }
            );

            var username;
            switch(type) {
                case 'builtin':
                    username = yield* parser.getField('username');
                    var password = yield* parser.getField('password');
                    yield* credential.addBuiltin(username, password);
                    break;
                case 'twitter':
                    var id = yield* parser.getField('id');
                    username = yield* parser.getField('username');
                    var accessToken = yield* parser.getField('accessToken');
                    var accessTokenSecret = yield* parser.getField('accessTokenSecret');
                    yield* credential.addTwitter(id, username, accessToken, accessTokenSecret);
                    break;
            }
            yield* credential.save();
            return credential;
        }
    };


    Credential.prototype.save = function*() {
        return yield* credentialStore.save(this);
    };


    /*
        Create a credential token.
        This can be used to upgrade to a user token, which is then used for login.
    */
    Credential.prototype.createSession = function*() {
        var schemaManager = services.getSchemaManager();
        var session = new models.Session(
            {
                credentialId: DbConnector.getRowId(this),
                token: randomizer.uniqueId(24)
            }
        );
        yield* session.save();
        return session;
    };


    Credential.prototype.addBuiltin = function*(username, password) {
        var existing = yield* credentialStore.findOne({ "builtin.username": username });
        if (!existing) {
            var hashed = yield generatorify(hasher)({ plaintext: password });
            this.builtin = {
                method: 'PBKDF2',
                username: username,
                salt: hashed.salt.toString('hex'),
                hash: hashed.key.toString('hex')
            };
        } else {
            throw new Error("Built-in credential with the same username already exists");
        }
    };


    Credential.prototype.addTwitter = function*(id, username, accessToken, accessTokenSecret) {
        var existing = yield* credentialStore.findOne({ "twitter.id": id });
        if (!existing) {
            this.twitter = {
                id: id,
                username: username,
                accessToken: accessToken,
                accessTokenSecret: accessTokenSecret
            };
        } else {
            throw new Error("Twitter credential with the same id already exists");
        }
    };


    exports.Credential = Credential;

})();
