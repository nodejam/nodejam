utils = require '../utils'


class TypeUtils
    

    isPrimitiveType: (type) ->      
        ['string', 'number', 'integer', 'boolean', 'array'].indexOf(type) > -1   


    
    isCustomType: (type) ->
        not @isPrimitiveType type



    completeTypeDefinition: (def, ctor) =>
        def.ctor = ctor

        def.schema ?= {} 
        def.schema.properties ?= {}
        def.schema.required ?= []

        if def.autoGenerated
            for k, v of def.autoGenerated
                def.schema.properties[k] = { type: 'integer' }
                def.schema.required.push k
        
        def
        

    
    resolveReferences: =>*
        for name, def of TypeUtils.typeCache
            for property, value of def.schema.properties
                if value.type is 'array'
                    if typeof value.items.type is 'object'
                        def.schema.properties[property].items.typeDefinition = { name: "<anonymous>", schema: value.items.type }
                    else if value.items.$ref
                        def.schema.properties[property].items.typeDefinition = yield @getTypeDefinition value.items.$ref
                else
                    if value.type is 'object'
                        def.schema.properties[property].typeDefinition = { name: "<anonymous>", schema: value.type }
                    else if value.$ref
                        def.schema.properties[property].typeDefinition = yield @getTypeDefinition value.$ref
        return
        


    getTypeDefinition: (name, dynamicResolutionContext = {}) =>*
        #We must initialize the cache first.
        if not TypeUtils.typeCache
            TypeUtils.typeCache = {}
            
            if @getCacheItems
                items = yield @getCacheItems()

                for modelName, def of items                    
                    TypeUtils.typeCache[modelName] = def        
            
                yield @resolveReferences()
        
        #First check if it resolves in type cache
        #Then check if it resolves in the context
        #Otherwise build
        return (TypeUtils.typeCache[name] ? dynamicResolutionContext[name]) ? yield @resolveDynamicTypeDefinition(name, dynamicResolutionContext)

    

    resolveDynamicTypeDefinition: (name) =>*
        throw new Error "MUST_OVERRIDE"



exports.TypeUtils = TypeUtils
