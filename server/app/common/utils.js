// Generated by CoffeeScript 1.6.2
(function() {
  var clone, dumpError, extend, fixUrl, isComposite, mergeLinkedObjects, mergeObjects, root, uniqueId;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  clone = function(source) {
    return JSON.parse(JSON.stringify(source));
  };

  extend = function(target, source) {
    var key, val;

    for (key in source) {
      val = source[key];
      target[key] = val;
    }
    return target;
  };

  isComposite = function(dataType) {
    return dataType !== 'Text' && dataType !== 'Number' && dataType !== 'Boolean' && dataType !== 'DateTime' && dataType !== 'Selection' && dataType !== 'HTML' && dataType !== 'File';
  };

  mergeObjects = function(target, source) {
    var key, mergeArrays, val;

    mergeArrays = function(targetArr, sourceArr) {
      var item, matches, newArr, x, _i, _j, _k, _len, _len1, _len2, _results;

      newArr = [];
      for (_i = 0, _len = sourceArr.length; _i < _len; _i++) {
        item = sourceArr[_i];
        matches = (function() {
          var _j, _len1, _results;

          _results = [];
          for (_j = 0, _len1 = targetArr.length; _j < _len1; _j++) {
            x = targetArr[_j];
            if (x.name === item.name) {
              _results.push(x);
            }
          }
          return _results;
        })();
        if (matches.length > 0) {
          mergeObjects(matches[0], item);
        } else {
          newArr.push(item);
        }
      }
      for (_j = 0, _len1 = targetArr.length; _j < _len1; _j++) {
        item = targetArr[_j];
        newArr.push(item);
      }
      targetArr.length = 0;
      _results = [];
      for (_k = 0, _len2 = newArr.length; _k < _len2; _k++) {
        item = newArr[_k];
        _results.push(targetArr.push(item));
      }
      return _results;
    };
    for (key in source) {
      val = source[key];
      if (!target[key]) {
        target[key] = val;
      } else {
        if (val) {
          if (val instanceof Array) {
            mergeArrays(target[key], val);
          } else if (typeof val === 'object') {
            mergeObjects(target[key], val);
          }
        }
      }
    }
  };

  mergeLinkedObjects = function(obj, fieldName) {
    if (obj[fieldName]) {
      mergeLinkedObjects(obj[fieldName], fieldName);
      return mergeObjects(obj, obj[fieldName]);
    }
  };

  uniqueId = function(length) {
    var id;

    if (length == null) {
      length = 16;
    }
    id = "";
    while (id.length < length) {
      id += Math.random().toString(36).substr(2);
    }
    return id.substr(0, length);
  };

  fixUrl = function(url) {
    if (/http:\/\//.test(url)) {
      return url;
    } else {
      return "http://" + url;
    }
  };

  dumpError = function(err) {
    if (err) {
      if (typeof err === 'object') {
        if (err.message) {
          console.log('\nError: ' + err.message);
        }
      }
      if (err.stack) {
        console.log('\nStacktrace:');
        console.log('===========');
        return console.log(err.stack);
      } else {
        return console.log("Error: " + (JSON.stringify(err)));
      }
    } else {
      return console.log('Error: null or undefined.');
    }
  };

  root.clone = clone;

  root.extend = extend;

  root.isComposite = isComposite;

  root.mergeObjects = mergeObjects;

  root.mergeLinkedObjects = mergeLinkedObjects;

  root.uniqueId = uniqueId;

  root.fixUrl = fixUrl;

  root.dumpError = dumpError;

}).call(this);
